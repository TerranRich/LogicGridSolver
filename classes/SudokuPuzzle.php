<?php

namespace App\Classes;

/**
 * SudokuPuzzle class
 *
 * Generates a sudoku puzzle that is generated by first filling the diagonal
 * subgrids with random numbers, then solving the puzzle to fill the rest of the
 * subgrids. The puzzle is then shuffled to create a unique puzzle. Some numbers
 * are then removed from the puzzle to create a final puzzle with the specified
 * difficulty level.
 *
 * The puzzle is stored as a 9x9 array of numbers (0-9) and a mask to hide
 * numbers based on the difficulty level. Both the puzzle and the solution can
 * be retrieved as a 9x9 array or flat string.
 */

class SudokuPuzzle {

  // Sudoku puzzle block (0 = empty, 1-9 = number).
  private $block = [];
  // Mask for puzzle (0 = hidden, 1 = visible).
  private $mask = [];
  // Number of collisions.
  private $collisions = 0;
  // Difficulty level (0-9).
  private $difficulty = 0;
  // Maximum difficulty level (0 = beginner, 9 = expert, 10 = empty).
  private $diff_max = 10;
  // Solution for sudoku puzzle.
  private $solution = [];

  private const SIZE = 9;
  private const SUBGRID_SIZE = 3;
  private const EMPTY_CELL = "0";

  /**
   * Set the difficulty level and initialize the puzzle.
   *
   * @param int $level Difficulty level (0-9)
   * @return void
   */
  public function __construct(int $level = 0) {
    $this->difficulty = max(min($this->diff_max, $level), 0);
    $this->init();
    $this->generatePuzzle();
  }

  /**
   * Retrieve the puzzle as a 9x9 array.
   *
   * @return array
   */
  private function getPuzzle() : array {
    $puzzle = [];

    // Create the puzzle array.
    for ($i = 0; $i < self::SIZE; $i++) {
      for ($j = 0; $j < self::SIZE; $j++) {
        $puzzle[$i][$j] = $this->mask[$i][$j] == 0
          ? "" : $this->block[$i][$j];
      }
    }

    return $puzzle;
  }

  /**
   * Retrieves the generated puzzle as a flat, easier-to-read string.
   *
   * @return string
   */
  public function getPuzzleFlatString() : string {
    return $this->flattenPuzzle($this->getPuzzle());
  }

  /**
   * Retrieves the solution to the generated puzzle in array format.
   *
   * @return array
   */
  public function getSolution() : array {
    return $this->solution;
  }

  /**
   * Retrieves the solution to the generated puzzle as a flat string.
   *
   * @return string
   */
  public function getSolutionFlatString() : string {
    return $this->flattenPuzzle($this->solution);
  }

  /**
   * Initialize the puzzle with a seed and initial values.
   *
   * @return void
   */
  private function init() : void {
    $s = self::SIZE;
    $this->seed();
    $this->collisions = 0;
    $this->block = array_fill(0, $s, array_fill(0, $s, self::EMPTY_CELL));
    $this->mask  = array_fill(0, $s, array_fill(0, $s, 1));
  }

  /**
   * Seed the random number generator.
   *
   * @return void
   */
  private function seed() : void {
    $seed = crc32(microtime());
    srand($seed);
  }

  /**
   * Generate the Sudoku puzzle by filling it, storing the solution, then
   * removing numbers based on the difficulty level.
   *
   * @return void
   */
  private function generatePuzzle() : void {
    $this->fillPuzzle();
    $this->solution = $this->block;
    $this->removeNumbers();
  }

  /**
   * Fill the puzzle by first populating its initial values, shuffling the rows
   * and columns and then all numbers to create a unique puzzle, then solving
   * the puzzle to fill the rest of the subgrids.
   *
   * @return void
   */
  private function fillPuzzle() : void {
    $this->populateInitialValues();
    $this->shuffleRowsAndColumns();
    $this->shuffleAllNumbers();
    $this->solve();
  }

  /**
   * Fill in the diagonal subgrids with random numbers, then solve the puzzle to
   * fill the rest of the subgrids.
   *
   * @return void
   */
  private function populateInitialValues() : void {
    $s = self::SIZE;
    $g = self::SUBGRID_SIZE;
    // Fill the diagonal subgrids.
    for ($i = 0; $i < $s; $i += $g) {
      $this->fillSubgrid($i, $i);
    }
    // Fill the rest of the subgrids.
    $this->solve();
  }

  /**
   * Fill a subgrid with random numbers.
   *
   * @param int $row Row index of the subgrid
   * @param int $col Column index of the subgrid
   * @return void
   */
  private function fillSubgrid(int $row, int $col) : void {
    $g = SELF::SUBGRID_SIZE;
    $numbers = range(1, self::SIZE);
    shuffle($numbers);

    // Fill the subgrid with random numbers.
    for ($i = 0; $i < $g; $i++) {
      for ($j = 0; $j < $g; $j++) {
        $this->block[$row + $i][$col + $j] = array_pop($numbers);
      }
    }
  }

  /**
   * Shuffle the rows and columns within each 3x3 subgrid.
   *
   * @return void
   */
  private function shuffleRowsAndColumns() : void {
    $s = self::SIZE;
    $g = self::SUBGRID_SIZE;

    // Shuffle rows within each 3x3 subgrid.
    for ($i = 0; $i < $s; $i += $g) {
      $rows = range($i, $i + $g - 1);
      shuffle($rows);
      $temp = array_slice($this->block, $i, $g);
      foreach ($rows as $index => $row) {
        $this->block[$i + $index] = $temp[$row - $i];
      }
    }

    // Shuffle columns within each 3x3 subgrid.
    for ($j = 0; $j < $s; $j += $g) {
      $cols = range($j, $j + $g - 1);
      shuffle($cols);
      $temp = [];
      for ($i = 0; $i < $s; $i++) {
        $temp[$i] = array_slice($this->block[$i], $j, $g);
      }
      foreach ($cols as $index => $col) {
        for ($i = 0; $i < $s; $i++) {
          $this->block[$i][$j + $index] = $temp[$i][$col - $j];
        }
      }
    }
  }

  /**
   * Shuffle all numbers in the puzzle to help create a unique puzzle.
   *
   * @return void
   */
  private function shuffleAllNumbers() : void {
    $s = self::SIZE;
    $numbers = range(1, 9);
    shuffle($numbers);
    $numberMap = array_combine(range(1, 9), $numbers);
    for ($i = 0; $i < $s; $i++) {
      for ($j = 0; $j < $s; $j++) {
        if ($this->block[$i][$j] !== self::EMPTY_CELL) {
          $this->block[$i][$j] = (string)$numberMap[$this->block[$i][$j]];
        }
      }
    }
  }

  /**
   * Initial call to solve the puzzle starts here, initiating a recursive back-
   * tracking algorithm at cell 0,0.
   *
   * @return void
   */
  private function solve() : void {
    $this->solveRecursive(0, 0);
  }

  /**
   * Solve the puzzle using a recursive backtracking algorithm.
   *
   * @param int $i Row index
   * @param int $j Column index
   * @return bool
   */
  private function solveRecursive(int $i, int $j) : bool {
    $s = self::SIZE;
    $z = self::EMPTY_CELL;

    if ($i == $s) {
      $i = 0;
      if (++$j == $s) {
        return true;
      }
    }
    if ($this->block[$i][$j] != $z) {
      return $this->solveRecursive($i + 1, $j);
    }
    for ($val = 1; $val <= $s; $val++) {
      if ($this->isValid($i, $j, $val)) {
        $this->block[$i][$j] = (string)$val;
        if ($this->solveRecursive($i + 1, $j)) {
          return true;
        }
      }
    }
    $this->block[$i][$j] = $z;
    return false;
  }

  /**
   * Check if a number is valid in the current cell.
   *
   * @param int $i Row index
   * @param int $j Column index
   * @param int $val Number to check
   * @return bool
   */
  private function isValid(int $i, int $j, int $val) : bool {
    $g = self::SUBGRID_SIZE;
    $valStr = (string)$val;

    for ($k = 0; $k < self::SIZE; $k++) {
      if ($this->block[$i][$k] == $valStr || $this->block[$k][$j] == $valStr) {
        return false;
      }
    }

    $rowStart = floor($i / $g) * $g;
    $colStart = floor($j / $g) * $g;

    for ($r = 0; $r < $g; $r++) {
      for ($c = 0; $c < $g; $c++) {
        if ($this->block[$rowStart + $r][$colStart + $c] == $valStr) {
          return false;
        }
      }
    }

    return true;
  }

  /**
   * Remove numbers from the puzzle to create the final puzzle based on given
   * difficulty level.
   *
   * @return void
   */
  private function removeNumbers() : void {
    $s = self::SIZE;
    $z = self::EMPTY_CELL;
    $attempts = 0;
    $max_attempts = $s * $s;

    // Attempt to remove numbers from the puzzle.
    while ($attempts < $max_attempts) {
      $row = rand(0, $s - 1);
      $col = rand(0, $s - 1);
      if ($this->block[$row][$col] != $z) {
        $backup = $this->block[$row][$col];
        $this->block[$row][$col] = $z;
        if (!$this->hasUniqueSolution($this->block)) {
          // Restore the number if it has multiple solutions.
          $this->block[$row][$col] = $backup;
        } else {
          // Update the mask to hide this number.
          $this->mask[$row][$col] = 0;
        }
      }
      $attempts++;
    }
  }

  /**
   * Check if the puzzle has a unique solution.
   *
   * @param array $board Sudoku puzzle
   * @return bool
   */
  private function hasUniqueSolution(array $board) : bool {
    return $this->countSolutions($board) == 1;
  }

  /**
   * Counting the number of solutions for the puzzle starts here, where a
   * recursive backtracking algorithm is initiated at cell 0,0.
   *
   * @param array $board Sudoku puzzle
   * @return int
   */
  private function countSolutions(array $board) : int {
    return $this->countSolutionsRecursive($board, 0, 0);
  }

  /**
   * Recursive backtracking algorithm to count the number of solutions for the
   * puzzle.
   *
   * @param array $board Sudoku puzzle
   * @param int $i Row index
   * @param int $j Column index
   * @return int
   */
  private function countSolutionsRecursive(array &$board, int $i, int $j): int {
    $s = self::SIZE;
    $z = self::EMPTY_CELL;

    // Move to the next cell.
    if ($i == $s) {
      $i = 0;
      if (++$j == $s) {
        return 1;
      }
    }

    // Skip cells that are already filled.
    if ($board[$i][$j] != $z) {
      return $this->countSolutionsRecursive($board, $i + 1, $j);
    }

    $count = 0;

    // Try all possible values for the current cell.
    for ($val = 1; $val <= $s; $val++) {
      if ($this->isValidInBoard($board, $i, $j, $val)) {
        $board[$i][$j] = (string)$val;
        $count += $this->countSolutionsRecursive($board, $i + 1, $j);
      }
    }
    // Restore the cell to its original state.
    $board[$i][$j] = $z;

    return $count;
  }

  /**
   * Check if a number is valid in the current cell.
   *
   * @param array $board Sudoku puzzle
   * @param int $i Row index
   * @param int $j Column index
   * @param int $val Number to check
   * @return bool
   */
  private function isValidInBoard(array $board, int $i, int $j, int $val):bool {
    $g = self::SUBGRID_SIZE;
    $valStr = (string)$val;

    // Check the row and column for the number.
    for ($k = 0; $k < self::SIZE; $k++) {
      if ($board[$i][$k] == $valStr || $board[$k][$j] == $valStr) {
        return false;
      }
    }

    // Find the start of the subgrid.
    $rowStart = floor($i / $g) * $g;
    $colStart = floor($j / $g) * $g;

    // Check the subgrid for the number.
    for ($r = 0; $r < $g; $r++) {
      for ($c = 0; $c < $g; $c++) {
        if ($board[$rowStart + $r][$colStart + $c] == $valStr) {
          return false;
        }
      }
    }

    // If we're here, then the number is valid.
    return true;
  }

  /**
   * Flatten the puzzle into a string.
   *
   * @param array $puzzle Sudoku puzzle
   * @return string
   */
  private function flattenPuzzle(array $puzzle) : string {
    $flat = '';
    foreach ($puzzle as $row) {
      foreach ($row as $cell) {
        $flat .= $cell ?: self::EMPTY_CELL;
      }
    }
    return $flat;
  }

}
